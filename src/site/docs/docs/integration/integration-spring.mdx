---
title: Spring
slug: /integration/spring
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

This document describes how to integrate Wirespec-generated code with Spring Boot applications. Wirespec simplifies the
creation of type-safe and well-defined APIs, and this integration provides a seamless way to use those APIs within your
Spring applications.

The integration is compatible with Spring Boot 3 and 4, and relies on Jackson 2 for serialization and deserialization.

The integration works for both [producers](#restcontroller) (RestController) and [consumers](#webclient)
(WebClient).

## Setup

<Tabs>
    <TabItem value="maven" label="Maven">

        Add both the dependency and plugin to your `pom.xml` file:

        ```xml
        <dependency>
            <groupId>community.flock.wirespec.integration</groupId>
            <artifactId>spring-jvm</artifactId>
            <version>{{WIRESPEC_VERSION}}</version>
        </dependency>
        ```

        ```xml
        <plugin>
            <groupId>community.flock.wirespec.plugin.maven</groupId>
            <artifactId>wirespec-maven-plugin</artifactId>
            <version>{{WIRESPEC_VERSION}}</version>
            <dependency>
                <groupId>community.flock.wirespec.integration</groupId>
                <artifactId>spring-jvm</artifactId>
                <version>{{WIRESPEC_VERSION}}</version>
            </dependency>
            <executions>
                <execution>
                    <id>java</id>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                    <configuration>
                        <input>${project.basedir}/src/main/wirespec</input>
                        <output>${project.build.directory}/generated-sources</output>
                        <emitterClass>community.flock.wirespec.integration.spring.java.emit.SpringJavaEmitter</emitterClass>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        ```

    </TabItem>
    <TabItem value="gradle" label="Gradle">
        Add the dependency to your depedencies, as well as the plugin dependencies

        For single module project this is in the `build.gradle.kts`

        ```gradle
        import community.flock.wirespec.integration.spring.java.emit.SpringJavaEmitter

        buildscript {
            dependencies {
                classpath("community.flock.wirespec.integration:spring:{{WIRESPEC_VERSION}}")
            }
        }
        ```

        For multi-module projects add the plugin dependency also to your `buildSrc/build.gradle.kts`, and the `build.gradle.kts` of the module to which you want to add the wirespec plugin

        ```gradle
        tasks.register<CompileWirespecTask>("wirespec-compile") {
            description = "Compile Wirespec to Java"
            group = "Wirespec compile"
            input = layout.projectDirectory.dir("src/main/wirespec")
            output = layout.buildDirectory.dir("generated")
            packageName = "community.flock.wirespec.generated.java"
            emitterClass = community.flock.wirespec.integration.spring.java.emit.SpringJavaEmitter::class.java
            languages = listOf(Language.Java)
        }
        ```

    </TabItem>

</Tabs>

:::info
Make sure to use the latest version, found here:

![Maven Central](https://img.shields.io/maven-central/v/community.flock.wirespec.plugin.maven/wirespec-maven-plugin)
:::

---

## Creating and compiling a definition

Now that the setup is complete, we'll add our Wirespec definition in `src/main/wirespec/`, matching the directory we
specified as input in the configuration. The example below contains a simple Todo type and GET endpoint:

[//]: # "Could be the same as in getting-started maybe?"

```wirespec title="src/main/wirespec/todo.ws"
type TodoDto {
    id: Integer,
    task: String
}

endpoint GetTodo GET /api/todos/{id: Integer} -> {
    200 -> TodoDto
    400 -> String
}
```

<br />

Now we can compile our definition and generate sources to the specified output directory by running the following
command:

<Tabs>
    <TabItem value="maven" label="Maven">
        ```bash
        mvn install
        ```
    </TabItem>
    <TabItem value="gradle" label="Gradle">
        ```bash
        ./gradlew build
        ```
    </TabItem>

</Tabs>

:::note
It's not necessary to understand the ins and outs of the generated code, so we won't go into detail here.
However, if you're interested to learn more you can look [here](../emitters/java).
:::

## RestController

To enable the RestController integration you can simply add the `@EnableWirespecController` annotation to your
application's configuration class:

```java
@SpringBootApplication
// highlight-next-line
@EnableWirespecController
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

<br />

Next, we'll create a simple controller and implement the Wirespec-generated Handler interface for the endpoint we want
to expose:

```java
@RestController
class TodoController implements GetTodoEndpoint.Handler {

    @Override
    public CompletableFuture<GetTodoEndpoint.Response<?>> getTodo(GetTodoEndpoint.Request request) {
        TodoDto dto = new TodoDto(request.getPath().id(), "Create a Wirespec definition");
        return completedFuture(new GetTodoEndpoint.Response200(dto));
    }
}
```

<br />

That's all we need to create a type safe API, see the result for yourself:

```bash
curl http://localhost:8080/api/todos/1 # > {"id":1,"task":"Create a Wirespec definition"}
```

### Accessing parameters

Various request parameters are available on the `GetTodoEndpoint.Request` object. All of them return a `record` matching
your Wirespec definition.

```java
request.getBody();      // Request body
request.getHeaders();   // Request headers
request.getQueries();   // Query parameters
request.getPath();      // Path parameters
```

In the example from the previous sections we defined the `id` path parameter (`/api/todos/{id: Integer}`). Thus,
we can access it like so:

```java
Long id = request.getPath().id();
```

### HTTP Header Case Insensitivity

The Spring integration adheres to **RFC 7230**, which specifies that HTTP header names are case-insensitive. This means:

- **Request headers**: Incoming headers can be sent with any casing (e.g., `Content-Type`, `content-type`, `CONTENT-TYPE`) and will be correctly mapped to your Wirespec definition
- **Response headers**: Outgoing headers are sent as defined in your Wirespec specification, but clients can read them case-insensitively

For example, if your Wirespec definition includes a header `X-Request-ID`:

```wirespec
endpoint GetData GET /api/data #{ `X-Request-ID`: String } -> {
    200 -> DataType #{ `X-Response-ID`: String }
}
```

The handler can receive the request header regardless of how the client sends it (`X-Request-ID`, `x-request-id`, `X-REQUEST-ID`, etc.):

```java
@RestController
class DataController implements GetData.Handler {
    @Override
    public CompletableFuture<GetData.Response<?>> getData(GetData.Request request) {
        // Works with any casing of the header sent by the client
        String requestId = request.getHeaders().XRequestID();
        return completedFuture(new GetData.Response200(data, requestId));
    }
}
```

### Query Parameter Case Sensitivity

Unlike HTTP headers, **query parameters are case-sensitive** as specified by **RFC 3986**. This means:

- Query parameter names must match the exact casing defined in your Wirespec specification
- `?status=active` is different from `?Status=active` or `?STATUS=active`

For example, with this Wirespec definition:

```wirespec
endpoint GetTodos GET /api/todos ?{ done: Boolean? } -> {
    200 -> TodoDto[]
}
```

The query parameter must be sent exactly as `done`:

```bash
curl http://localhost:8080/api/todos?done=true  # ✓ Correct
curl http://localhost:8080/api/todos?Done=true  # ✗ Will not match
curl http://localhost:8080/api/todos?DONE=true  # ✗ Will not match
```

## WebClient

To enable the WebClient integration you can simply add the `@EnableWirespecWebClient` annotation to your application's
configuration class:

```java
@SpringBootApplication
// highlight-next-line
@EnableWirespecWebClient
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

:::note

If you want to use both the Controller _and_ WebClient you can use: `@EnableWirespec`

:::

<br />

Additionally, you should configure `base-url` in one of the following ways. By default, it uses the Spring Reactive
WebClient, but this is not required. If you would like to use another WebClient, or specify additional configuration,
you can do so by declaring a configuration bean.

<Tabs>
    <TabItem value="properties" label="Properties">
        ```properties title="application.properties"
        wirespec.spring.webclient.base-url=http://localhost:8080
        ```
    </TabItem>
    <TabItem value="yaml" label="YAML">
        ```yaml title="application.yml"
        wirespec:
          spring:
            webclient:
              base-url: 'http://localhost:8080'
        ```
    </TabItem>
    <TabItem value="bean" label="Configuration Bean">
        ```java title="WebClientConfig.java"
        @Configuration
        public class WebClientConfig {

            @Bean("wirespecSpringWebClient")
            public WebClient webClient(WebClient.Builder builder) {
                return builder
                    .baseUrl("http://localhost:8080")
                    .build();
            }
        }
        ```
    </TabItem>

</Tabs>

---

<br />

Finally, we can inject the WebClient and make a call to an upstream service. The constructor of the request class has
the required parameters specified in your definition, in this case the `id` path parameter. The WebClient always returns
a `CompletableFuture` of one of the specified responses.

```java
@Service
public class TodoService {

    private final WirespecWebClient webClient;

    public TodoService(WirespecWebClient webClient) {
        this.webClient = webClient;
    }

    public CompletableFuture<GetTodoEndpoint.Response<?>> getById(long id) {
        return webClient.send(new GetTodoEndpoint.Request(id));
    }
}
```

:::info RFC 7230 Compliance

The WebClient also adheres to RFC 7230 for case-insensitive header handling. Response headers from upstream services
are processed case-insensitively, so you can access them reliably regardless of the casing used by the server.

:::

## Handling Multipart Requests

Wirespec supports `multipart/form-data` requests by defining a type that represents the form fields. Binary data (files) should be defined using the `Bytes` type.

### Definition

Define the request body type with the fields you expect in the multipart request. Use `Bytes` for file uploads.

```wirespec
type FileUploadRequest {
  file: Bytes,
  description: String
}

endpoint UploadFile POST FileUploadRequest /upload -> {
  200 -> String
}
```

### Controller

In the Spring controller, the request body is automatically mapped to the defined type. You can access the binary data as a `byte[]`.

```java
@RestController
class FileController implements UploadFile.Handler {

    @Override
    public CompletableFuture<UploadFile.Response<?>> uploadFile(UploadFile.Request request) {
        byte[] fileContent = request.getBody().file();
        String description = request.getBody().description();

        // Process the file...

        return CompletableFuture.completedFuture(new UploadFile.Response200("File uploaded successfully"));
    }
}
```

## Conclusion

This was a quick but comprehensive introduction to the Spring integration for Wirespec. As you might have noticed, the
definitions we specified earlier work seamlessly on both sides, and the requests/responses are identical regardless of
whether we are interacting with the producer or consumer. This is **central to Wirespec's design**.

A fully running application with more examples, showcasing Wirespec's features
[is available on GitHub](https://github.com/flock-community/wirespec-demo-java-spring).
