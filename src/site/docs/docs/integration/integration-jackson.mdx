---
title: Jackson
slug: /integration/jackson
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you're using Jackson for serialization/deserialization you can make use of the Wirespec Jackson plugin to ensure
proper behaviour in all cases. Though not strictly required in all scenarios we recommend that you always use the
jackson integration to avoid unexpected behavior.

## Setup

<Tabs>
    <TabItem value="maven" label="Maven">
        ```xml title="pom.xml"
        <dependency>
            <groupId>community.flock.wirespec.integration</groupId>
            <artifactId>jackson</artifactId>
            <version>0.14.3</version>
        </dependency>
        ```
    </TabItem>
    <TabItem value="gradle" label="Gradle">
        ```gradle title="build.gradle.kts"
        implementation("community.flock.wirespec.integration:jackson:0.14.3")
        ```
    </TabItem>
</Tabs>

:::info
Make sure to use the latest version, found here:

![Maven Central](https://img.shields.io/maven-central/v/community.flock.wirespec.plugin.maven/wirespec-maven-plugin)
:::

------------------------------

## Enums and Refined types

We want to make use of the language's built in strong typing/ type safety:

```java

```

## Language keywords

Wirespec can sometimes conflict with the language specifics of the target language. For example, it is not possible to
declare a variable in Java named `final`, but we may still want to have such a contract:

```wirespec
type Document {
    content: String,
    // highlight-next-line
    final: Boolean // A keyword in Java
}
```

In this case, the contract will remain unchanged, but for serialization and deserialization we will prefix this variable
with an `_`:

```java
public record Document(
    String content,
    // highlight-next-line
    Boolean _final
) {}
```
